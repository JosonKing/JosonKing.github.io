(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{375:function(t,a,e){"use strict";e.r(a);var r=e(42),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"高级指引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#高级指引"}},[t._v("#")]),t._v(" 高级指引")]),t._v(" "),e("h2",{attrs:{id:"代码分割"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码分割"}},[t._v("#")]),t._v(" 代码分割")]),t._v(" "),e("h3",{attrs:{id:"打包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#打包"}},[t._v("#")]),t._v(" 打包")]),t._v(" "),e("p",[t._v("大多数 React 应用都会使用 Webpack，Rollup 或 Browserify 这类的构建工具来打包文件。 打包是一个将文件引入并合并到一个单独文件的过程，最终形成一个 “bundle”。 接着在页面上引入该 bundle，整个应用即可一次性加载。")]),t._v(" "),e("p",[t._v("示例\nApp文件：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// app.js\nimport { add } from './math.js';\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("console.log(add(16, 26)); // 42\n// math.js\nexport function add(a, b) {\n  return a + b;\n}\n")])])]),e("p",[t._v("打包后文件：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function add(a, b) {\n  return a + b;\n}\n\nconsole.log(add(16, 26)); // 42\n")])])]),e("h3",{attrs:{id:"代码分割-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码分割-2"}},[t._v("#")]),t._v(" 代码分割")]),t._v(" "),e("p",[t._v("打包是个非常棒的技术，但随着你的应用增长，你的代码包也将随之增长。尤其是在整合了体积巨大的第三方库的情况下。你需要关注你代码包中所包含的代码，以避免因体积过大而导致加载时间过长。")]),t._v(" "),e("p",[t._v("为了避免搞出大体积的代码包，在前期就思考该问题并对代码包进行分割是个不错的选择。 代码分割是由诸如 Webpack，Rollup 和 Browserify（factor-bundle）这类打包器支持的一项技术，能够创建多个包并在运行时动态加载。")]),t._v(" "),e("p",[t._v("对你的应用进行代码分割能够帮助你“懒加载”当前用户所需要的内容，能够显著地提高你的应用性能。尽管并没有减少应用整体的代码体积，但你可以避免加载用户永远不需要的代码，并在初始加载的时候减少所需加载的代码量。")]),t._v(" "),e("h4",{attrs:{id:"import"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#import"}},[t._v("#")]),t._v(" import()")]),t._v(" "),e("p",[t._v("在你的应用中引入代码分割的最佳方式是通过动态 import() 语法。")]),t._v(" "),e("p",[t._v("使用之前：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import { add } from './math';\n\nconsole.log(add(16, 26));\n")])])]),e("p",[t._v("使用之后：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('import("./math").then(math => {\n  console.log(math.add(16, 26));\n});\n')])])]),e("p",[t._v("当 Webpack 解析到该语法时，会自动进行代码分割。如果你使用 Create React App，该功能已开箱即用，你可以立刻使用该特性。Next.js 也已支持该特性而无需进行配置。")]),t._v(" "),e("p",[t._v("如果你自己配置 Webpack，你可能要阅读下 Webpack 关于代码分割的指南。你的 Webpack 配置应该类似于此。")]),t._v(" "),e("p",[t._v("当使用 Babel 时，你要确保 Babel 能够解析动态 import 语法而不是将其进行转换。对于这一要求你需要 babel-plugin-syntax-dynamic-import 插件。")]),t._v(" "),e("h2",{attrs:{id:"context"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#context"}},[t._v("#")]),t._v(" Context")]),t._v(" "),e("blockquote",[e("p",[t._v("Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。")])]),t._v(" "),e("p",[t._v("在一个典型的 React 应用中，数据是通过 props 属性自上而下（由父及子）进行传递的，但这种做法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，UI 主题），这些属性是应用程序中许多组件都需要的。Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。")]),t._v(" "),e("h3",{attrs:{id:"何时使用-context"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#何时使用-context"}},[t._v("#")]),t._v(" 何时使用 Context")]),t._v(" "),e("p",[t._v("Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。")]),t._v(" "),e("h3",{attrs:{id:"使用-context-之前的考虑"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-context-之前的考虑"}},[t._v("#")]),t._v(" 使用 Context 之前的考虑")]),t._v(" "),e("p",[t._v("在组件树中很多不同层级的组件需要访问同样的一批数据。Context 能让你将这些数据向组件树下所有的组件进行“广播”，所有的组件都能访问到这些数据，也能访问到后续的数据更新。使用 context 的通用的场景包括管理当前的 locale，theme，或者一些缓存数据，这比替代方案要简单的多。")]),t._v(" "),e("h3",{attrs:{id:"api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#api"}},[t._v("#")]),t._v(" API")]),t._v(" "),e("h2",{attrs:{id:"错误边界"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#错误边界"}},[t._v("#")]),t._v(" 错误边界")]),t._v(" "),e("h3",{attrs:{id:"错误边界-error-boundaries"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#错误边界-error-boundaries"}},[t._v("#")]),t._v(" 错误边界（Error Boundaries）")]),t._v(" "),e("p",[t._v("部分 UI 的 JavaScript 错误不应该导致整个应用崩溃，为了解决这个问题，React 16 引入了一个新的概念 —— 错误边界。")]),t._v(" "),e("p",[t._v("错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI，而不是渲染那些崩溃了的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。")]),t._v(" "),e("blockquote",[e("p",[t._v("错误边界无法捕获以下场景中产生的错误：")]),t._v(" "),e("ul",[e("li",[t._v("事件处理（了解更多）")]),t._v(" "),e("li",[t._v("异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）")]),t._v(" "),e("li",[t._v("服务端渲染")]),t._v(" "),e("li",[t._v("它自身抛出来的错误（并非它的子组件）")])])]),t._v(" "),e("p",[t._v("如果一个 class 组件中定义了 static getDerivedStateFromError() 或 componentDidCatch() 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。当抛出错误后，请使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息。")]),t._v(" "),e("p",[t._v("错误边界的工作方式类似于 JavaScript 的 catch {}，不同的地方在于错误边界只针对 React 组件。只有 class 组件才可以成为错误边界组件。大多数情况下, 你只需要声明一次错误边界组件, 并在整个应用中使用它。")]),t._v(" "),e("p",[t._v("注意错误边界仅可以捕获其子组件的错误，它无法捕获其自身的错误。如果一个错误边界无法渲染错误信息，则错误会冒泡至最近的上层错误边界，这也类似于 JavaScript 中 catch {} 的工作机制。")]),t._v(" "),e("h3",{attrs:{id:"未捕获错误-uncaught-errors-的新行为"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#未捕获错误-uncaught-errors-的新行为"}},[t._v("#")]),t._v(" 未捕获错误（Uncaught Errors）的新行为")]),t._v(" "),e("p",[t._v("自 React 16 起，任何未被错误边界捕获的错误将会导致整个 React 组件树被卸载。")]),t._v(" "),e("h2",{attrs:{id:"refs-转发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#refs-转发"}},[t._v("#")]),t._v(" Refs 转发")]),t._v(" "),e("blockquote",[e("p",[t._v("Ref 转发是一项将 ref 自动地通过组件传递到其一子组件的技巧。对于可重用的组件库是很有用的。")])]),t._v(" "),e("h3",{attrs:{id:"转发-refs-到-dom-组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#转发-refs-到-dom-组件"}},[t._v("#")]),t._v(" 转发 refs 到 DOM 组件")]),t._v(" "),e("p",[t._v("FancyButton 或 MyTextInput 这样的高可复用“叶”组件倾向于在整个应用中以一种类似常规 DOM button 和 input 的方式被使用，并且访问其 DOM 节点对管理焦点，选中或动画来说是不可避免的。")]),t._v(" "),e("p",[t._v("Ref 转发是一个可选特性，其允许某些组件接收 ref，并将其向下传递（换句话说，“转发”它）给子组件。")]),t._v(" "),e("h2",{attrs:{id:"高阶组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件"}},[t._v("#")]),t._v(" 高阶组件")]),t._v(" "),e("blockquote",[e("p",[t._v("高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。")])]),t._v(" "),e("blockquote",[e("p",[t._v("高阶组件是参数为组件，返回值为新组件的函数。")])]),t._v(" "),e("h3",{attrs:{id:"使用-hoc-解决横切关注点问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-hoc-解决横切关注点问题"}},[t._v("#")]),t._v(" 使用 HOC 解决横切关注点问题")]),t._v(" "),e("p",[t._v("在一个大型应用程序中，我们需要一个抽象，允许我们在一个地方定义相同逻辑，并在许多组件之间共享它。这正是高阶组件擅长的地方。")]),t._v(" "),e("p",[t._v("编写一个创建组件函数。该函数将接受一个子组件作为它的其中一个参数，该子组件将订阅数据作为 prop。")]),t._v(" "),e("p",[t._v("HOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件包装在容器组件中来组成新组件。HOC 是纯函数，没有副作用。")]),t._v(" "),e("p",[t._v("被包装组件接收来自容器组件的所有 prop，同时也接收一个新的用于 render 的 data prop。HOC 不需要关心数据的使用方式或原因，而被包装组件也不需要关心数据是怎么来的。")]),t._v(" "),e("h3",{attrs:{id:"不要改变原始组件-使用组合"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不要改变原始组件-使用组合"}},[t._v("#")]),t._v(" 不要改变原始组件,使用组合")]),t._v(" "),e("h2",{attrs:{id:"与第三方库协同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#与第三方库协同"}},[t._v("#")]),t._v(" 与第三方库协同")]),t._v(" "),e("h3",{attrs:{id:"集成带有-dom-操作的插件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#集成带有-dom-操作的插件"}},[t._v("#")]),t._v(" 集成带有 DOM 操作的插件")]),t._v(" "),e("p",[t._v("我们会添加一个 ref 到这个根 DOM 元素。 在 componentDidMount 中，我们能够获取它的引用这样我们就可以把它传递给 jQuery 插件了。")]),t._v(" "),e("p",[t._v("为了防止 React 在挂载之后去触碰这个 DOM，我们会从 render() 函数返回一个空的 "),e("code",[t._v("<div />")]),t._v("。这个 "),e("code",[t._v("<div />")]),t._v(" 元素既没有属性也没有子元素，所以 React 没有理由去更新它，使得 jQuery 插件可以自由的管理这部分的 DOM：")]),t._v(" "),e("h2",{attrs:{id:"深入-jsx"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#深入-jsx"}},[t._v("#")]),t._v(" 深入 JSX")]),t._v(" "),e("p",[t._v("JSX 仅仅只是 React.createElement(component, props, ...children) 函数的语法糖。如下 JSX 代码：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<MyButton color="blue" shadowSize={2}>\n  Click Me\n</MyButton>\n')])])]),e("p",[t._v("会编译为：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("React.createElement(\n  MyButton,\n  {color: 'blue', shadowSize: 2},\n  'Click Me'\n)\n")])])]),e("h3",{attrs:{id:"在运行时选择类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在运行时选择类型"}},[t._v("#")]),t._v(" 在运行时选择类型")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React from 'react';\nimport { PhotoStory, VideoStory } from './stories';\n\nconst components = {\n  photo: PhotoStory,\n  video: VideoStory\n};\n\nfunction Story(props) {\n  // 正确！JSX 类型可以是大写字母开头的变量。\n  const SpecificStory = components[props.storyType];\n  return <SpecificStory story={props.story} />;\n}\n")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);