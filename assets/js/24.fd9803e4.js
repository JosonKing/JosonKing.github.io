(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{371:function(t,e,s){"use strict";s.r(e);var a=s(42),o=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"react-redux-的用法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-redux-的用法"}},[t._v("#")]),t._v(" React-Redux 的用法")]),t._v(" "),s("p",[t._v("如何在 React 项目中使用 Redux。为了方便使用，Redux 的作者封装了一个 React 专用的库 React-Redux。")]),t._v(" "),s("h2",{attrs:{id:"一、ui-组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、ui-组件"}},[t._v("#")]),t._v(" 一、UI 组件")]),t._v(" "),s("p",[t._v("React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）。")]),t._v(" "),s("p",[t._v('UI 组件（又称为"纯组件"）有以下几个特征。')]),t._v(" "),s("ul",[s("li",[t._v("只负责 UI 的呈现，不带有任何业务逻辑")]),t._v(" "),s("li",[t._v("没有状态（即不使用this.state这个变量）")]),t._v(" "),s("li",[t._v("所有数据都由参数（this.props）提供")]),t._v(" "),s("li",[t._v("不使用任何 Redux 的 API")])]),t._v(" "),s("h2",{attrs:{id:"二、容器组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、容器组件"}},[t._v("#")]),t._v(" 二、容器组件")]),t._v(" "),s("ul",[s("li",[t._v("负责管理数据和业务逻辑，不负责 UI 的呈现")]),t._v(" "),s("li",[t._v("带有内部状态")]),t._v(" "),s("li",[t._v("使用 Redux 的 API")])]),t._v(" "),s("p",[t._v("UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。")]),t._v(" "),s("p",[t._v("如果一个组件既有 UI 又有业务逻辑，将它拆分成下面的结构：外面是一个容器组件，里面包了一个UI 组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图。")]),t._v(" "),s("p",[t._v("React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。用户负责视觉层，状态管理则是全部交给它。")]),t._v(" "),s("h2",{attrs:{id:"三、connect"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、connect"}},[t._v("#")]),t._v(" 三、connect()")]),t._v(" "),s("p",[t._v("React-Redux 提供connect方法，用于从 UI 组件生成容器组件。connect的意思，就是将这两种组件连起来。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("import { connect } from 'react-redux'\nconst VisibleTodoList = connect()(TodoList);\n")])])]),s("p",[t._v("TodoList是 UI 组件，VisibleTodoList就是由 React-Redux 通过connect方法自动生成的容器组件。")]),t._v(" "),s("p",[t._v("（1）输入逻辑：外部的数据（即state对象）如何转换为 UI 组件的参数")]),t._v(" "),s("p",[t._v("（2）输出逻辑：用户发出的动作如何变为 Action 对象，从 UI 组件传出去。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("import { connect } from 'react-redux'\n\nconst VisibleTodoList = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(TodoList)\n")])])]),s("p",[t._v("上面代码中，connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。")]),t._v(" "),s("h2",{attrs:{id:"四、mapstatetoprops"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、mapstatetoprops"}},[t._v("#")]),t._v(" 四、mapStateToProps()")]),t._v(" "),s("p",[t._v("mapStateToProps是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。")]),t._v(" "),s("p",[t._v("作为函数，mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射。")]),t._v(" "),s("p",[t._v("mapStateToProps是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。")]),t._v(" "),s("p",[t._v("作为函数，mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("const mapStateToProps = (state) => {\n  return {\n    todos: getVisibleTodos(state.todos, state.visibilityFilter)\n  }\n}\n")])])]),s("p",[t._v("mapStateToProps会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。")]),t._v(" "),s("p",[t._v("mapStateToProps的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('// 容器组件的代码\n//    <FilterLink filter="SHOW_ALL">\n//      All\n//    </FilterLink>\n\nconst mapStateToProps = (state, ownProps) => {\n  return {\n    active: ownProps.filter === state.visibilityFilter\n  }\n}\n')])])]),s("p",[t._v("使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染。")]),t._v(" "),s("p",[t._v("connect方法可以省略mapStateToProps参数，那样的话，UI 组件就不会订阅Store，就是说 Store 的更新不会引起 UI 组件的更新。")]),t._v(" "),s("h2",{attrs:{id:"五、mapdispatchtoprops"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五、mapdispatchtoprops"}},[t._v("#")]),t._v(" 五、mapDispatchToProps()")]),t._v(" "),s("p",[t._v("mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射。也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。")]),t._v(" "),s("p",[t._v("如果mapDispatchToProps是一个函数，会得到dispatch和ownProps（容器组件的props对象）两个参数。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("const mapDispatchToProps = (\n  dispatch,\n  ownProps\n) => {\n  return {\n    onClick: () => {\n      dispatch({\n        type: 'SET_VISIBILITY_FILTER',\n        filter: ownProps.filter\n      });\n    }\n  };\n}\n")])])]),s("p",[t._v("从上面代码可以看到，mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action。")]),t._v(" "),s("p",[t._v("如果mapDispatchToProps是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出。举例来说，上面的mapDispatchToProps写成对象就是下面这样。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("const mapDispatchToProps = {\n  onClick: (filter) => {\n    type: 'SET_VISIBILITY_FILTER',\n    filter: filter\n  };\n}\n")])])]),s("h2",{attrs:{id:"六、-组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#六、-组件"}},[t._v("#")]),t._v(" 六、"),s("Provider",[t._v(" 组件")])],1),t._v(" "),s("p",[t._v("connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成 UI 组件的参数。")]),t._v(" "),s("p",[t._v("一种解决方法是将state对象作为参数，传入容器组件。但是，这样做比较麻烦，尤其是容器组件可能在很深的层级，一级级将state传下去就很麻烦。")]),t._v(" "),s("p",[t._v("React-Redux 提供Provider组件，可以让容器组件拿到state。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("import { Provider } from 'react-redux'\nimport { createStore } from 'redux'\nimport todoApp from './reducers'\nimport App from './components/App'\n\nlet store = createStore(todoApp);\n\nrender(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n)\n")])])]),s("p",[t._v("上面代码中，Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了。")]),t._v(" "),s("p",[t._v("它的原理是React组件的context属性，请看源码。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("class Provider extends Component {\n  getChildContext() {\n    return {\n      store: this.props.store\n    };\n  }\n  render() {\n    return this.props.children;\n  }\n}\n\nProvider.childContextTypes = {\n  store: React.PropTypes.object\n}\n")])])]),s("p",[t._v("上面代码中，store放在了上下文对象context上面。然后，子组件就可以从context拿到store，代码大致如下。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("class VisibleTodoList extends Component {\n  componentDidMount() {\n    const { store } = this.context;\n    this.unsubscribe = store.subscribe(() =>\n      this.forceUpdate()\n    );\n  }\n\n  render() {\n    const props = this.props;\n    const { store } = this.context;\n    const state = store.getState();\n    // ...\n  }\n}\n\nVisibleTodoList.contextTypes = {\n  store: React.PropTypes.object\n}\n")])])]),s("p",[t._v("React-Redux自动生成的容器组件的代码，就类似上面这样，从而拿到store。")])])}),[],!1,null,null,null);e.default=o.exports}}]);