(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{374:function(e,t,s){"use strict";s.r(t);var r=s(42),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"中间件与异步操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#中间件与异步操作"}},[e._v("#")]),e._v(" 中间件与异步操作")]),e._v(" "),s("p",[e._v("Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步。")]),e._v(" "),s("p",[e._v("Reducer 在异步操作结束后自动执行，这就要用到新的工具：中间件（middleware）。\n"),s("img",{attrs:{src:"http://www.ruanyifeng.com/blogimg/asset/2016/bg2016092002.jpg",alt:"异步"}})]),e._v(" "),s("h2",{attrs:{id:"一、中间件的概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、中间件的概念"}},[e._v("#")]),e._v(" 一、中间件的概念")]),e._v(" "),s("p",[e._v("中间件就是一个函数，对store.dispatch方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。")]),e._v(" "),s("h2",{attrs:{id:"二、中间件的用法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、中间件的用法"}},[e._v("#")]),e._v(" 二、中间件的用法")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("import { applyMiddleware, createStore } from 'redux';\nimport createLogger from 'redux-logger';\nconst logger = createLogger();\n\nconst store = createStore(\n reducer,\n applyMiddleware(logger)\n);\n")])])]),s("p",[e._v("上面代码中，redux-logger提供一个生成器createLogger，可以生成日志中间件logger。然后，将它放在applyMiddleware方法之中，传入createStore方法，就完成了store.dispatch()的功能增强。")]),e._v(" "),s("ol",[s("li",[s("p",[e._v("createStore方法可以接受整个应用的初始状态作为参数，那样的话，applyMiddleware就是第三个参数了。")])]),e._v(" "),s("li",[s("p",[e._v("中间件的次序有讲究。")])])]),e._v(" "),s("h2",{attrs:{id:"三、applymiddlewares"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、applymiddlewares"}},[e._v("#")]),e._v(" 三、applyMiddlewares()")]),e._v(" "),s("p",[e._v("applyMiddlewares 是 Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("export default function applyMiddleware(...middlewares) {\n  return (createStore) => (reducer, preloadedState, enhancer) => {\n    var store = createStore(reducer, preloadedState, enhancer);\n    var dispatch = store.dispatch;\n    var chain = [];\n\n    var middlewareAPI = {\n      getState: store.getState,\n      dispatch: (action) => dispatch(action)\n    };\n    chain = middlewares.map(middleware => middleware(middlewareAPI));\n    dispatch = compose(...chain)(store.dispatch);\n\n    return {...store, dispatch}\n  }\n}\n")])])]),s("p",[e._v("所有中间件被放进了一个数组chain，然后嵌套执行，最后执行store.dispatch。可以看到，中间件内部（middlewareAPI）可以拿到getState和dispatch这两个方法。")]),e._v(" "),s("h2",{attrs:{id:"四、异步操作的基本思路"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、异步操作的基本思路"}},[e._v("#")]),e._v(" 四、异步操作的基本思路")]),e._v(" "),s("p",[e._v("同步操作只要发出一种 Action 即可，异步操作的差别是它要发出三种 Action。")]),e._v(" "),s("ul",[s("li",[e._v("操作发起时的 Action")]),e._v(" "),s("li",[e._v("操作成功时的 Action")]),e._v(" "),s("li",[e._v("操作失败时的 Action")])]),e._v(" "),s("p",[e._v("以向服务器取出数据为例，三种 Action 可以有两种不同的写法。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 写法一：名称相同，参数不同\n{ type: 'FETCH_POSTS' }\n{ type: 'FETCH_POSTS', status: 'error', error: 'Oops' }\n{ type: 'FETCH_POSTS', status: 'success', response: { ... } }\n\n// 写法二：名称不同\n{ type: 'FETCH_POSTS_REQUEST' }\n{ type: 'FETCH_POSTS_FAILURE', error: 'Oops' }\n{ type: 'FETCH_POSTS_SUCCESS', response: { ... } }\n")])])]),s("p",[e._v("除了 Action 种类不同，异步操作的 State 也要进行改造，反映不同的操作状态。下面是 State 的一个例子。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("let state = {\n  // ... \n  isFetching: true,\n  didInvalidate: true,\n  lastUpdated: 'xxxxxxx'\n};\n")])])]),s("p",[e._v("State 的属性isFetching表示是否在抓取数据。didInvalidate表示数据是否过时，lastUpdated表示上一次更新时间。")]),e._v(" "),s("ul",[s("li",[e._v('操作开始时，送出一个 Action，触发 State 更新为"正在操作"状态，View 重新渲染')]),e._v(" "),s("li",[e._v('操作结束后，再送出一个 Action，触发 State 更新为"操作结束"状态，View 再一次重新渲染')])]),e._v(" "),s("h2",{attrs:{id:"五、redux-thunk-中间件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五、redux-thunk-中间件"}},[e._v("#")]),e._v(" 五、redux-thunk 中间件")]),e._v(" "),s("p",[e._v("异步操作至少要送出两个 Action：用户触发第一个 Action，这个跟同步操作一样；通过 Action Creator 在操作结束时，系统自动送出第二个 Action。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class AsyncApp extends Component {\n  componentDidMount() {\n    const { dispatch, selectedPost } = this.props\n    dispatch(fetchPosts(selectedPost))\n  }\n\n// ...\n")])])]),s("p",[e._v("上面代码是一个异步组件的例子。加载成功后（componentDidMount方法），它送出了（dispatch方法）一个 Action，向服务器要求数据 fetchPosts(selectedSubreddit)。这里的fetchPosts就是 Action Creator。\n"),s("img",{attrs:{src:"http://www.ruanyifeng.com/blogimg/asset/2016/bg2016092003.jpg",alt:"fetchPosts"}})]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const fetchPosts = postTitle => (dispatch, getState) => {\n  dispatch(requestPosts(postTitle));\n  return fetch(`/some/API/${postTitle}.json`)\n    .then(response => response.json())\n    .then(json => dispatch(receivePosts(postTitle, json)));\n  };\n};\n\n// 使用方法一\nstore.dispatch(fetchPosts('reactjs'));\n// 使用方法二\nstore.dispatch(fetchPosts('reactjs')).then(() =>\n  console.log(store.getState())\n);\n")])])]),s("p",[e._v("（1）fetchPosts返回了一个函数，而普通的 Action Creator 默认返回一个对象。")]),e._v(" "),s("p",[e._v("（2）返回的函数的参数是dispatch和getState这两个 Redux 方法，普通的 Action Creator 的参数是 Action 的内容。")]),e._v(" "),s("p",[e._v("（3）在返回的函数之中，先发出一个 Action（requestPosts(postTitle)），表示操作开始。")]),e._v(" "),s("p",[e._v("（4）异步操作结束之后，再发出一个 Action（receivePosts(postTitle, json)），表示操作结束。")]),e._v(" "),s("p",[e._v("这样的处理，就解决了自动发送第二个 Action 的问题。但是，又带来了一个新的问题，Action 是由store.dispatch方法发送的。而store.dispatch方法正常情况下，参数只能是对象，不能是函数。")]),e._v(" "),s("p",[e._v("这时，就要使用中间件redux-thunk。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("import { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport reducer from './reducers';\n\n// Note: this API requires redux@>=3.1.0\nconst store = createStore(\n  reducer,\n  applyMiddleware(thunk)\n);\n")])])]),s("p",[e._v("上面代码使用redux-thunk中间件，改造store.dispatch，使得后者可以接受函数作为参数。")]),e._v(" "),s("p",[e._v("因此，异步操作的第一种解决方案就是，写出一个返回函数的 Action Creator，然后使用redux-thunk中间件改造store.dispatch。")]),e._v(" "),s("h2",{attrs:{id:"六、redux-promise-中间件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#六、redux-promise-中间件"}},[e._v("#")]),e._v(" 六、redux-promise 中间件")]),e._v(" "),s("p",[e._v("既然 Action Creator 可以返回函数，当然也可以返回其他值。另一种异步操作的解决方案，就是让 Action Creator 返回一个 Promise 对象。")]),e._v(" "),s("p",[e._v("这就需要使用redux-promise中间件。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("import { createStore, applyMiddleware } from 'redux';\nimport promiseMiddleware from 'redux-promise';\nimport reducer from './reducers';\n\nconst store = createStore(\n  reducer,\n  applyMiddleware(promiseMiddleware)\n); \n")])])]),s("p",[e._v("这个中间件使得store.dispatch方法可以接受 Promise 对象作为参数。这时，Action Creator 有两种写法。")]),e._v(" "),s("p",[e._v("写法一，返回值是一个 Promise 对象。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const fetchPosts = \n  (dispatch, postTitle) => new Promise(function (resolve, reject) {\n     dispatch(requestPosts(postTitle));\n     return fetch(`/some/API/${postTitle}.json`)\n       .then(response => {\n         type: 'FETCH_POSTS',\n         payload: response.json()\n       });\n});\n")])])]),s("p",[e._v("写法二，Action 对象的payload属性是一个 Promise 对象。这需要从redux-actions模块引入createAction方法，并且写法也要变成下面这样。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("import { createAction } from 'redux-actions';\n\nclass AsyncApp extends Component {\n  componentDidMount() {\n    const { dispatch, selectedPost } = this.props\n    // 发出同步 Action\n    dispatch(requestPosts(selectedPost));\n    // 发出异步 Action\n    dispatch(createAction(\n      'FETCH_POSTS', \n      fetch(`/some/API/${postTitle}.json`)\n        .then(response => response.json())\n    ));\n  }\n")])])]),s("p",[e._v("上面代码中，第二个dispatch方法发出的是异步 Action，只有等到操作结束，这个 Action 才会实际发出。注意，createAction的第二个参数必须是一个 Promise 对象。")]),e._v(" "),s("p",[e._v("redux-promise 源码：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("export default function promiseMiddleware({ dispatch }) {\nreturn next => action => {\n  if (!isFSA(action)) {\n    return isPromise(action)\n      ? action.then(dispatch)\n      : next(action);\n  }\n\n  return isPromise(action.payload)\n    ? action.payload.then(\n        result => dispatch({ ...action, payload: result }),\n        error => {\n          dispatch({ ...action, payload: error, error: true });\n          return Promise.reject(error);\n        }\n      )\n    : next(action);\n};\n}\n")])])]),s("p",[e._v("从上面代码可以看出，如果 Action 本身是一个 Promise，它 resolve 以后的值应该是一个 Action 对象，会被dispatch方法送出（action.then(dispatch)），但 reject 以后不会有任何动作；如果 Action 对象的payload属性是一个 Promise 对象，那么无论 resolve 和 reject，dispatch方法都会发出 Action。")])])}),[],!1,null,null,null);t.default=a.exports}}]);