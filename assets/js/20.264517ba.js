(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{367:function(a,t,o){"use strict";o.r(t);var s=o(42),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,o=a._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[o("h1",{attrs:{id:"hook"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#hook"}},[a._v("#")]),a._v(" HOOK")]),a._v(" "),o("h2",{attrs:{id:"简介"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[a._v("#")]),a._v(" 简介")]),a._v(" "),o("blockquote",[o("p",[a._v("Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。")])]),a._v(" "),o("h3",{attrs:{id:"没有破坏性改动"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#没有破坏性改动"}},[a._v("#")]),a._v(" 没有破坏性改动")]),a._v(" "),o("ul",[o("li",[a._v("完全可选的。 你无需重写任何已有代码就可以在一些组件中尝试 Hook。但是如果你不想，你不必现在就去学习或使用 Hook。")]),a._v(" "),o("li",[a._v("100% 向后兼容的。 Hook 不包含任何破坏性改动。")]),a._v(" "),o("li",[a._v("现在可用。 Hook 已发布于 v16.8.0。")])]),a._v(" "),o("h3",{attrs:{id:"动机"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#动机"}},[a._v("#")]),a._v(" 动机")]),a._v(" "),o("h4",{attrs:{id:"在组件之间复用状态逻辑很难"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#在组件之间复用状态逻辑很难"}},[a._v("#")]),a._v(" 在组件之间复用状态逻辑很难")]),a._v(" "),o("p",[a._v("React 需要为共享状态逻辑提供更好的原生途径。Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。Hook 使你在无需修改组件结构的情况下复用状态逻辑。 这使得在组件间或社区内共享 Hook 变得更便捷。")]),a._v(" "),o("h4",{attrs:{id:"复杂组件变得难以理解"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#复杂组件变得难以理解"}},[a._v("#")]),a._v(" 复杂组件变得难以理解")]),a._v(" "),o("p",[a._v("被状态逻辑和副作用充斥。每个生命周期常常包含一些不相关的逻辑。Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。还可以使用 reducer 来管理组件的内部状态，使其更加可预测。")]),a._v(" "),o("h4",{attrs:{id:"难以理解的-class"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#难以理解的-class"}},[a._v("#")]),a._v(" 难以理解的 class")]),a._v(" "),o("p",[a._v("Hook 使你在非 class 的情况下可以使用更多的 React 特性。React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则。Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术。")]),a._v(" "),o("h3",{attrs:{id:"hook-使用规则"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#hook-使用规则"}},[a._v("#")]),a._v(" Hook 使用规则")]),a._v(" "),o("p",[a._v("Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则：")]),a._v(" "),o("ul",[o("li",[a._v("只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。")]),a._v(" "),o("li",[a._v("只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中，我们稍后会学习到。）")])])])}),[],!1,null,null,null);t.default=r.exports}}]);